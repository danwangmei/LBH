1 let命令
1.1 用于变量声明,用法类似于var
1.1.1 let所声明的变量只在let命令所在的代码块内有效,{}即块级作用域中有效

1.2 不存在变量提升
1.2.1 var命令存在变量提升的现象,即变量可以在声明之前使用,值为undefined
console.log(a)//输出 undefined
var a = 1;
---------------------------------
-->声明变量提升,代码重构为
var a;
console.log(a);
a = 1;
---------------------------------
console.log(a)//报错
let a = 1;
-->let没有变量提升
-------------------------------
1.2.2 let命令所声明的变量一定要在声明之后使用,否则便会报错

1.3 暂时性死区
1.3.1 只要块级作用域存在let命令,他所声明的变量就"绑定"这个区域,不再受外部的影响.
for (var i= 0; i < 3; i++) {
    setTimeout(function(){
        console.log(i)
    },1000*i)
}//输出3 3 3 
-->异步编程,i在全局作用域,当执行到定时器时i=3
-------------------------------
for (let i= 0; i < 3; i++) {
    setTimeout(function(){
        console.log(i)
    },1000*i)
}//输出0 1 2
-->异步编程,i在块级作用域中,每次执行for循环中的i都会生成一个块级作用域

1.4 不允许重复声明
1.4.1 let不允许在相同的作用域内重复声明同一个变量
var a = 1;
function a(){

}//不会报错
--------------------------------
let a = 1;
function a(){

}//报错

1.5 函数提升优先级高于变量提升
var a =1;
function a(){

};
console.log(a);//1
---------------------------------
-->函数提升,函数提升优先级高于变量提升,变量提升不会覆盖(同名)函数提升,只有变量再次赋值时,才会被覆盖,代码重构为
function a(){

};
var a;
a = 1;
console.log(a);
-------------------------------